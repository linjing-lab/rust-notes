# 数据类型

## 静态编译型语言

Rust是静态编译语言，在编译时必须知道所有变量的类型

* 基于使用的值，编译器通常能够推断出它的具体类型
* 但是如果可能的类型比较多（例如把String转为整数的parese()方法），就必须添加类型的标注，否则编译会报错。

```rust
let guess: u32 = "42".parse().expect("Not a number");
println!("The guess is number {}", guess);
```

类型标注：

```rust
guess: u32
```

## 标量

第一，一个标量类型代表一个单个的值。

第二，Rust有四个主要的标量类型：

**整数类型**

* 整数类型没有小数部分
* `u32`就是一个无符号的整数类型，占据32位的空间
* 无符号整数类型以`u`开头
* 有符号整数类型以`i`开头
* 整数类型，每种都分`i`和`u`，以及固定的位数
  * 有符号的范围：[2^n - 1, 2^(n-1) - 1]
  * 无符号的范围：[0, 2^n - 1]
  * arch: 表示系统的架构
* isize和usize类型
  * 位数由程序运行的计算机的架构所决定
    * 如果是64位计算机，那就是64位的
    * ...
  * 使用isize和usize的主要场景是对某种集合进行索引操作。
* 整数的字面值

| Number Literals | Example           |
| --------------- | ----------------- |
| Decimal         | 98_222（加`_`增强可读性） |
| Hex（十六进制）       | 0xff              |
| Octal（八进制）      | 0o77              |
| Binary（二进制）     | 0b1111_0000       |
| Byte(u8 only)   | b'A'              |

除了byte类型意外，所有的数值字面值都允许适用类型后缀。（57u8）

如果你不太清楚应该是有哪种类型，可以使用`Rust`相应的默认类型

整数的默认类型是`i32`，总体来说速度很快，即使在64位系统中。

**整数的溢出**：`u8`的范围是0-255，如果你把一个`u8`变量的值设为256，那么：

* 调试模式下编译：`Rust`会检查整数溢出，如果发生溢出，程序在运行时就会`panic`

* 发布模式下（--release）编译：`Rust`不会检查可能导致`panic`的整数溢出
  
  * 如果溢出发生：`Rust`会执行**环绕**操作
    
    * 256变成0，257变成1...
  
  * 程序不会panic

**浮点类型**

* `f32`，32位，单精度

* `f64`，64位，双精度

`Rust`的浮点类型使用了IEEE-754标准来表述

`f64`是默认类型，因为在现代CPU下，`f64`和`f32`的速度差不多，而且精度更高。

```rust
let z = 2.0; // f64
let r: f32 = 3.0; // f32
```

**数值操作**：

```rust
let sum = 5 + 10; // 以下均默认为f64
let difference = 95.5 - 4.3;
let product = 4 * 30;
let quotient = 56.7 / 32.2;
let reminder = 54 % 5;
```

**布尔类型**

* true和false

* 一个字节大小

* 符号是`bool`

```rust
let t = true; // 编译器会推断出来t的类型
let f: bool = false; // 显式指明f的类型位bool类型
```

**字符类型**

* `char`类型被用来描述语言中最基础的单个字符

* 字符类型的字面值使用单引号

* 占用4个字节大小

* 是Unicode标量值，可以表示比ASCII多得多的字符内容：拼音、中日韩文、零长度空白字符、emoji表情等。
  
  * U+0000到U+D7FF
  
  * U+E000到U+10FFFF

* Unicode中没有字符的概念，所以直觉上认为的字符也许与Rust中的概念并不相符。

## 复合类型

第一，复合类型可以将多个值放在一个类型中。

第二，Rust提供了两种基础的复合类型：元组（Tuple）、数组

**Tuple**

* 可以将多个类型的多个值放在一个类型里
* Tuple的长度是固定的：一旦声明就无法改变

**创建Tuple**

* 在小括号里，将值用逗号分开
* Tuple中的每个位置都对应一个类型，Tuple中各元素的类型不必相同

**获取Tupleu元素值**

* 可以使用模式匹配来解构（destructure）一个Tuple来获取元素的值

```rust
let tup: (i32, f64, u8) = (-500, 6.4, 1);
let (x, y, z) = tup;
println!("{}, {}, {}", x, y, z);
println!("{}, {}, {}", tup.0, tup.1, tup.2);
```

**数组**

* 也可以将多个值放在一个类型里面
* 每个元素的类型必须相同
* 数组的长度也是固定的

**声明一个数组**

* 在中括号里，各值用逗号分开

**数组的用处**

* 数据存放在`stack`（栈）上而不是`heap`（堆）上
* 保证有固定数量的元素，使用数组更好

数组没有`Vector`灵活

* Vector和数组类似，它由标准库提供
* Vector的长度可以改变
* 如果在数组和Vector抉择，那么估计你应该用Vector。

数组的类型表示

* [类型: 长度]

```rust
let a: [i32, 5] = [1, 2, 3, 4, 5];

```

声明数组的另法：如果数组的每个元素值都相同，那么可以在

* 在中括号里指定初始值

* 然后一个':'

* 最后是数组的长度

```rust
let a = [3: 5]; // let a = [3,3,3,3,3];
```

**访问数组元素**

* 数组是Stack上分配的单个块的内存

* 使用索引访问数组的元素

* 如果访问的索引超出了数组的范围，那么
  
  * 编译会通过（写的绕一点）
  
  * 运行会报错（runtime时会panic）
    
    * Rust不会允许其继续访问相应地址的内存