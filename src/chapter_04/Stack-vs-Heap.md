# 所有权：Stack vs Heap

所有权是Rust最独特的特性，它让Rust无需GC就可以保证内存安全。

## 什么是所有权

Rust的核心特性就是所有权。

所有程序在运行时都必须管理它们使用计算机内存的方式。
* 有些语言有垃圾收集机制，在程序运行时，它们会不断地寻找不再使用的内存。
* 在其他语言（C/C++）中，程序员必须显式地分配和释放内存

Rust采用第三种方式管理内存：
* 内存是通过一个所有权系统来管理的，其中包含一组编译器在编译时期检查的规则。
* 当程序运行时，所有权特性不会减慢程序的运行速度。
* Rust将内存管理的相关工作都提前到了编译时，没有运行时开销。

## 栈内存 vs 堆内存

在像Rust这样的系统级编程语言里，一个值是Stack上还是在heap上对语言的行为和你为什么要做某些决定是有更大的影响。

在你代码运行时，Stack和Heap都是你可用的内存，但他们的结构很不相同。

## 存储数据

Stack按值得接收顺序来存储，按相反得顺序将它们移除（后进先出，LIFO）
* 添加数据叫做-压入栈-
* 移除数据叫做-弹出栈-

所有存储在Stack上得数据必须拥有已知的固定的大小
* 编译时大小未知的数据或运行时大小可能发生变化的数据必须存放在heap上

Heap内存组织性差一些
* 当你把数据放入heap时，你会请求一定数量的空间
* 操作系统在heap里找到一块足够大的空间，把它标记为在用，并返回一个指针，也就是这个空间的地址。
* 此过程称为在heap上进行分配，有时仅仅称为“分配”

把值压入stack上不叫分配。

因为指针是已知固定大小的，可以把指针存放在stack上
* 如果想要实际数据，你必须使用指针来定位。

把数据压到stack上要比在heap上分配快得多
* 因为操作系统不需要寻找用来存储新数据的空间，那个位置永远都是stack的顶端

在heap上分配空间需要更多的工作
* 操作系统首先需要找到一个足够大的空间来存放数据，然后要做好记录方便下次分配。

## 访问数据

访问heap中的数据要比访问stack中的数据慢，因为需要通过指针才能找到heap中的数据
* 对于现代的处理器来说，由于缓存的缘故，如果指令在内存中跳转的次数越少，那么速度就越快。
* 服务员点菜的例子：点菜最高效的方式是点完一桌子菜再去点下一桌，而不是这一桌点了一个菜之后，跑去下一桌点菜，来回往返会花费很多时间。

由此上述例子可以得到，如果数据存放的距离比较近，那么处理器的处理速度会更快一些（比如将数据放在Stack上）

如果数据之间的距离比较远，那么处理速度就会慢一些（比如把数据放在heap上）
* 在heap上分配大量的空间也是需要时间的

## 函数调用

当你的代码调用函数时，值被传入到函数（包括指向heap的指针）。函数本地的变量被压入到stack上。当函数结束后，这些值会从stack上弹出。

## 所有权存在的原因

所有权解决的问题：
* 跟踪代码的哪些部分正在使用heap的哪些数据
* 最小化heap上的重复数据量
* 清理heap上未使用的数据以避免空间不足

一旦懂了所有权，那么就不需要经常去想stack或heap。

管理heap数据是所有权存在的原因。